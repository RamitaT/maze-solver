#pragma config(Sensor, S1,     wall1,          sensorEV3_Touch)
#pragma config(Sensor, S3,     wall2,          sensorEV3_Touch)
#pragma config(Sensor, S$4,     ultrasound,     sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          rightwheel,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          leftwheel,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//Gear ratio 24:16

//Create a structure representing each cell on the maze
typedef struct{
	int NWall;
	int SWall;
	int EWall;
	int WWall;
	char Visited;
}Cell;

Cell Maze[4][6]; // creates two dim. (4x6) array of structs

int encodeValueMotorA;
int encodeValueMotorD;
int Walldistance = 10;
int direction;
int soundActive = 0;
void cellinitial();
void ResetValue();
void Stop();
void TurnLeft();
void TurnRight();
void GoFwd();
void Adjust();


// direction
// 0 north
// 1 east
// 2 south
// 3 west

task main()
{
		cellinitial();
		ResetValue();

		//The robot begin by facing north direction
		direction = 0;

		//Array for storing robot's moving path
		int path[100];
		for(int i = 0; i < 100; i++){
			path[i] = -1;
		}
		//Index for Path array
		int ind = 0;

		int r_start = 0;
		int c_start = 0;

		//Enter starting cell
		while(getButtonPress(ENTER_BUTTON) != 1){
        displayCenteredBigTextLine(4, "starting cell");
    	displayCenteredBigTextLine(6, "row %d", r_start);
    	displayCenteredBigTextLine(8, "column %d", c_start);
            if(getButtonPress(UP_BUTTON)){
                r_start++;
            }
			else if(getButtonPress(DOWN_BUTTON)){
				r_start--;
			}
			else if(getButtonPress(RIGHT_BUTTON)){
				c_start++;
			}
			else if(getButtonPress(LEFT_BUTTON)){
				c_start--;
			}

			wait1Msec(200);

		}

		eraseDisplay();
		wait1Msec(300);

		int r_current = r_start;
		int c_current = c_start;

		int r_target = 0;
		int c_target = 0;

		//Enter the target cell
		while(getButtonPress(ENTER_BUTTON) != 1){
        displayCenteredBigTextLine(4, "target cell");
    	displayCenteredBigTextLine(6, "row %d", r_target);
    	displayCenteredBigTextLine(8, "column %d", c_target);

			if(getButtonPress(UP_BUTTON)){
				r_target++;
			}
			else if(getButtonPress(DOWN_BUTTON)){
				r_target--;
			}
			else if(getButtonPress(RIGHT_BUTTON)){
				c_target++;
			}
			else if(getButtonPress(LEFT_BUTTON)){
				c_target--;
			}

			wait1Msec(200);
		}

		displayCenteredBigTextLine(4, "starting cell");
		displayCenteredBigTextLine(6, "row %d	column	%d", r_current,c_current);
		displayCenteredBigTextLine(8, "target cell");
		displayCenteredBigTextLine(10, "row %d	column	%d", r_target,c_target);
		wait1Msec(500);

		flushButtonMessages();
		Stop();
		waitForButtonPress();
		eraseDisplay();

		//Start to solve the maze
        //Bumping into the wall to realign if there is a wall in the front & update wall information
		if(SensorValue[S4] <= Walldistance){
			Maze[r_start][c_start].NWall = 1;
			Stop();
			Adjust();
		}

		int adjustActive = 0;
		int starting = 1;

		while(r_current != r_target || c_current != c_target){
            //Update "visited" information
			Maze[r_current][c_current].Visited = 'Y';
			if(SensorValue[S4] <= Walldistance){
                //To activate the adjust fuction (for realignment)
                adjustActive = 1;
			}
			TurnRight();
			//If there is a wall
			if(SensorValue[S4] <= Walldistance){
                //Update the wall information to the structure called maze
				switch(direction){
					case 0: Maze[r_current][c_current].NWall = 1; break;
					case 1: Maze[r_current][c_current].EWall = 1; break;
					case 2: Maze[r_current][c_current].SWall = 1; break;
					case 3: Maze[r_current][c_current].WWall = 1; break;
					default : break;
				}
				if(adjustActive == 1 || starting){
					Stop();
					Adjust();
					starting = 0;
				}
				TurnLeft();
				while(SensorValue[S4] <= Walldistance){
					switch(direction){
						case 0: Maze[r_current][c_current].NWall = 1; break;
						case 1: Maze[r_current][c_current].EWall = 1; break;
						case 2: Maze[r_current][c_current].SWall = 1; break;
						case 3: Maze[r_current][c_current].WWall = 1; break;
						default : break;
					}
					if(adjustActive == 1 || starting){
						Stop();
						Adjust();
					}
					TurnLeft();
				}
				GoFwd();
                //Update the position of the robot
				switch(direction){
					case 0: r_current++; break;
					case 1: c_current++; break;
					case 2: r_current--; break;
					case 3: c_current--; break;
					default : break;
				}
			}
			//If there is no wall
			else{
				GoFwd();
                //Update the position of the robot
				switch(direction){
					case 0: r_current++; break;
					case 1: c_current++; break;
					case 2: r_current--; break;
					case 3: c_current--; break;
					default : break;
				}
			}
            //Store the path that robot move
			path[ind] = direction;
			ind++;
			adjustActive = 0;
            
            //Display position and direction on the brick screen
			displayCenteredBigTextLine(4, "row %d	column	%d", r_current,c_current);
			displayCenteredBigTextLine(6, "direction %d", direction);

			//Activate the sound when the robot reach the target cell
            if( r_current == r_target && c_current == c_target){
				soundActive = 1;
			}
		}
        //Make a beep for 2 sec. once the robot reach the target cell
		while(soundActive == 1){
			playTone(300,200);
			wait10Msec(200);
			soundActive = 0;
		}

		//Moving back to the starting cell using the shrotest cell
		//ind = the length of path array (from home to cheese)
		int begin_index;
		int end_index;
		int i = 0;

		//Scan through array to find shortest path
        //Scan through an array if there is a pair of opposite direction (N&S or E&W)
        //replace those elements with -1
		while(i < ind){
			if(path[i] == -1){
				if(i == 0){
					begin_index = i;
				}
				else{
					begin_index = i-1;
				}
				while(path[i] == -1){
					i++;
				}
				end_index = i;
				if(abs(path[begin_index]-path[end_index]) == 2){
					path[begin_index] = -1;
					path[end_index] = -1;
					i = 0;
				}
				else if(begin_index == 0 && abs(path[end_index]-path[end_index+1]) == 2){
					path[end_index] = -1;
					path[end_index+1] = -1;
					i = 0;
				}
			}
			else if(abs(path[i]-path[i+1]) == 2){
				if(i == 0){
					path[i] = -1;
					path[i+1] = -1;
					i = 0;
				}
				else if(i != 0 && path[i+1] != -1 && path[i-1] != -1 && i != 0){
					path[i] = -1;
					path[i+1] = -1;
					i = 0;
				}
				else{
					i++;
				}
			}
			else{
				i++;
			}
		}

		//Convert the direction & Go back to starting point
		i = 0;
		while(i < ind){
			switch(path[i]){
				case 0: path[i] = 2; break;
				case 1: path[i] = 3; break;
				case 2:	path[i] = 0; break;
				case 3: path[i] = 1; break;
				default : break;
			}
			i++;
		}

		for(int i = ind-1; i >= 0; i--){
			if(path[i] >= 0){
				while(path[i] != direction){
					ResetValue();
					if(path[i] > direction && path[i]-direction != 3){
						TurnRight();
						Stop();
					}
					else{
						TurnLeft();
						Stop();
					}
				}
				ResetValue();
				GoFwd();
				Stop();
  		}
  	}


}


//Functions:

//Initialize the outer wall of the maze & mark every cell as "unvisited"
void cellinitial(){
		for(int c=0;c<6;c++){
				Maze[0][c].SWall=1; // Bottom row
				Maze[3][c].NWall=1; // Top row
		}

		for(int r=0;r<4;r++){
				Maze[r][0].WWall=1; // Left Col
				Maze[r][5].EWall=1; // Right Col
		}
		for(int r=0;r<4;r++){
			for(int c=0;c<6;c++){
				Maze[r][c].Visited = 'U';
			}
		}
}

//Reset the encoder value of 2 large motors
void ResetValue(){
    resetMotorEncoder(motorA);
  	resetMotorEncoder(motorD);
  	encodeValueMotorA = getMotorEncoder(motorA);
  	encodeValueMotorD = getMotorEncoder(motorD);
}

//Stop the motors
void Stop(){
	motor[motorA] = 0;
	motor[motorD] = 0;
}

//Turn 90 degrees left and update the direction that robot is facing
void TurnLeft(){
	if(direction <= 0){
		direction = 3;
	}
	else{
		direction--;
	}
    ResetValue();
	while(encodeValueMotorD < 90*2.98 && encodeValueMotorA > -90*2.98){
        encodeValueMotorA = getMotorEncoder(motorA);
        encodeValueMotorD = getMotorEncoder(motorD);
        motor[motorA] = -10;
        motor[motorD] = 10;
	}
	Stop();
}

//Turn 90 degrees right and update the direction that robot is facing
void TurnLeft(){
void TurnRight(){
	if(direction >= 3){
		direction = 0;
	}
	else{
		direction++;
	}
    ResetValue();
    while(encodeValueMotorA < 90*3.02 && encodeValueMotorD > -90*3.02){
		encodeValueMotorA = getMotorEncoder(motorA);
        encodeValueMotorD = getMotorEncoder(motorD);
        motor[motorA] = 10;
        motor[motorD] = -10;
	}
	Stop();
}

//Goes forward from a center of one cell to a center of another cell
void GoFwd(){
    ResetValue();
	switch(direction){
        case 0:
            while(encodeValueMotorA < 725 && encodeValueMotorD < 730){
                encodeValueMotorA = getMotorEncoder(motorA);
                encodeValueMotorD = getMotorEncoder(motorD);
                motor[motorA] = 40;
                motor[motorD] = 40;
            }
            break;
        case 1:
            while(encodeValueMotorA < 745 && encodeValueMotorD < 750){
                encodeValueMotorA = getMotorEncoder(motorA);
                encodeValueMotorD = getMotorEncoder(motorD);
                motor[motorA] = 40;
                motor[motorD] = 40;
            }
            break;
        case 2:
            while(encodeValueMotorA < 725 && encodeValueMotorD < 730){
                encodeValueMotorA = getMotorEncoder(motorA);
                encodeValueMotorD = getMotorEncoder(motorD);
                motor[motorA] = 40;
                motor[motorD] = 40;
            }
            break;
        case 3:
            while(encodeValueMotorA < 745 && encodeValueMotorD < 750){
                encodeValueMotorA = getMotorEncoder(motorA);
                encodeValueMotorD = getMotorEncoder(motorD);
                motor[motorA] = 40;
                motor[motorD] = 40;
            }
            break;
        default: break;
    }
    Stop();
}

//Get called for realignment when there are NWall & EWall or EWall & SWall or SWall & WWall or WWall & NWall
//Bumping into the wall and back up to stay on the center of a cell
void Adjust(){
	while(SensorValue[S1] != 1 || SensorValue[S3] != 1){
		if(SensorValue[S1] == 1){
			motor[motorA] = 0;
            motor[motorD] = 50;
        }
        else if(SensorValue[S3] == 1){
            motor[motorA] = 50;
            motor[motorD] = 0;
        }
        else{
            motor[motorA] = 50;
            motor[motorD] = 50;
        }
    }
    Stop();
    wait1Msec(1000);
    switch(direction){
        case 0:
            while(SensorValue[S4] <= 4){
                motor[motorA] = -5;
                motor[motorD] = -5;
            }
            break;
        case 1:
            while(SensorValue[S4] <= 4.5){
                motor[motorA] = -5;
                motor[motorD] = -5;
            }
            break;
        case 2:
            while(SensorValue[S4] <= 4){
                motor[motorA] = -5;
                motor[motorD] = -5;
            }
            break;
        case 3:
            while(SensorValue[S4] <= 4.5){
                motor[motorA] = -5;
                motor[motorD] = -5;
            }
            break;
        default: break;
    }
    Stop();
}
